import java_cup.runtime.*;
action code {:
	SymbolTable table = new SymbolTable();
	String currentType = "";
:}

terminal INT;
terminal FLOAT;
terminal BREAK;
terminal CLASS;
terminal CONTINUE;
terminal IF,ELSE;
terminal FOR;
terminal WHILE;
terminal RETURN;
terminal VOID;
terminal TRUE, FALSE;
terminal ID;
terminal INT_LITERAL, STRING_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL;

terminal
		LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON,
		LPAREN, RPAREN, EQ, COMMA, PLUSEQ, MINUSEQ,
		EXTERNINVK, MINUS, NOT, PLUS, MULT, DIV, MOD,
		LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ, ANDAND, OROR;

non terminal	program,
				set_decl,
				field_decl,
				id_field_decl,
				list_id_field_decl,
				set_field_decl,
				method_decl,
				set_method_decl,
				zero_or_one_list_type_id_method_decl,
				list_type_id_method_decl,
				type_id_method_decl,
				block,
				type,
				statement,
				zero_or_one_else_block,
				set_statement,
				zero_or_one_expr,
				assign_op,
				method_call,
				location,
				list_expr,
				expr,
				externinvk_arg,
				list_externinvk_arg,
				zero_or_one_list_externinvk_arg,
				bin_op,
				arith_op,
				rel_op,
				eq_op,
				cond_op,
				literal,
				bool_literal;

precedence left  EQ, ANDAND, NOT, NOTEQ;
precedence left  OROR;
precedence left  LT, GT, LTEQ, GTEQ, EQEQ;
precedence left  PLUS, MINUS;
precedence left  MULT, DIV, MOD;


start with program;

program ::= 
		CLASS ID LBRACE {:table.insertNewBlock();:} set_decl RBRACE {:table.closeBlock();:} {:System.out.println("termino");:}
	|	CLASS ID LBRACE {:table.insertNewBlock();:} RBRACE {:table.closeBlock();:} {:System.out.println("termino");:}
	;

set_decl ::= 
		set_field_decl set_method_decl
	|	set_method_decl
	|	set_field_decl
	;

set_field_decl ::= 
		set_field_decl field_decl 
	|	field_decl
	;

field_decl ::= type list_id_field_decl SEMICOLON;

id_field_decl ::= 
		ID:i {:table.insertSymbol(currentType, i.toString());:} 
	|	ID:i {:table.insertSymbol(currentType, i.toString());:} LBRACK INT_LITERAL RBRACK
	;

list_id_field_decl ::= list_id_field_decl COMMA id_field_decl | id_field_decl;

method_decl ::= 
		type ID:i {:table.insertSymbol(currentType, i.toString());:} LPAREN zero_or_one_list_type_id_method_decl RPAREN {:table.insertNewBlock();:} block {:table.closeBlock();:}
	|	VOID ID:i {:table.insertSymbol("Void", i.toString());:} LPAREN zero_or_one_list_type_id_method_decl RPAREN {:table.insertNewBlock();:} block {:table.closeBlock();:}
	;


set_method_decl ::= method_decl set_method_decl | method_decl;

zero_or_one_list_type_id_method_decl ::=
		list_type_id_method_decl
	|	/* LAMBDA */
	;

list_type_id_method_decl ::= type_id_method_decl COMMA list_type_id_method_decl | type_id_method_decl;

type_id_method_decl ::= type ID:i {:table.insertSymbol(currentType, i.toString());:};

block ::= 
		LBRACE  set_field_decl set_statement RBRACE
	|	LBRACE set_statement RBRACE 
	|	LBRACE set_field_decl RBRACE
	;

type ::=
		BOOLEAN_LITERAL {:currentType = "boolean";:}
	|	FLOAT {:currentType = "float";:}
	|	INT {:currentType = "int";:}
	;

statement ::=
		location assign_op expr SEMICOLON
	|	method_call SEMICOLON
	|	IF LPAREN expr RPAREN {:table.insertNewBlock();:} block {:table.closeBlock();:} zero_or_one_else_block
	|	FOR ID EQ expr COMMA expr {:table.insertNewBlock();:} block {:table.closeBlock();:}
	|	WHILE expr {:table.insertNewBlock();:} block {:table.closeBlock();:}
	|	RETURN zero_or_one_expr SEMICOLON
	|	BREAK SEMICOLON
	|	CONTINUE SEMICOLON
	|	SEMICOLON
	|	{:table.insertNewBlock();:} block {:table.closeBlock();:}
	;

	
zero_or_one_else_block ::= ELSE {:table.insertNewBlock();:} block {:table.closeBlock();:} | /* LAMBDA */;
	
set_statement ::= statement set_statement | statement;

zero_or_one_expr ::= expr | /* LAMBDA */;

assign_op ::=
		EQ
	|	PLUSEQ
	|	MINUSEQ
	;

method_call ::= 
		ID LPAREN  RPAREN
	|	ID LPAREN list_expr RPAREN
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type RPAREN
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type COMMA list_externinvk_arg RPAREN
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA VOID RPAREN
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA VOID COMMA list_externinvk_arg RPAREN
	;

location ::= ID | ID LBRACK expr RBRACK;

list_expr ::= expr COMMA list_expr | expr;

expr ::=
		location
	|	method_call
	|	literal
	|	expr bin_op expr
	|	MINUS expr
	|	NOT expr
	|	LPAREN expr RPAREN
	;

externinvk_arg ::=
		expr
	|	STRING_LITERAL
	;
	
list_externinvk_arg ::= 
		externinvk_arg COMMA list_externinvk_arg 
	|	externinvk_arg
	;

zero_or_one_list_externinvk_arg ::= 
		list_externinvk_arg 
	|	/* empty */
	;

bin_op ::=
		arith_op
	|	rel_op
	|	eq_op
	|	cond_op
	;

arith_op ::=
		PLUS
	|	MINUS
	|	MULT
	|	DIV
	|	MOD
	;

rel_op ::=
		LT
	|	GT
	|	LTEQ
	|	GTEQ
	;

eq_op ::=
		EQEQ
	|	NOTEQ
	;

cond_op ::=
		ANDAND
	|	OROR
	;
	
literal ::=
		INT_LITERAL
	|	FLOAT_LITERAL
	|	bool_literal
	;

bool_literal ::=
		TRUE
	|	FALSE
	;