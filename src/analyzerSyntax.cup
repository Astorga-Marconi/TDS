/**
 * Copyright (C) 2014
 * All rights reserved.
 *
 * File Name: analizerSyntax.cup
 * To Create: cup analizerSyntax.cup
 * Authors: Astorga Dario - Marconi Pablo
 * Version: 0.1 
 */
import java_cup.runtime.*;
import ir.ast.*;
import java.util.*;

action code {:
	SymbolTable table = new SymbolTable();
	String currentType = "";
:}

/* Terminals (tokens obtained by the lexical analyzer) */
terminal BREAK;
terminal CLASS;
terminal CONTINUE;
terminal IF,ELSE;
terminal FOR;
terminal WHILE;
terminal RETURN;
terminal VOID;
terminal STRING_LITERAL;
terminal
		LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON,
		LPAREN, RPAREN, EQ, COMMA, PLUSEQ, MINUSEQ,
		EXTERNINVK, NOT;

terminal String ID;
terminal BinOpType PLUS, MINUS, MULT, DIV, MOD, LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ, ANDAND, OROR;
terminal Type TINT, TFLOAT, TBOOLEAN;
terminal IntLiteral INT_LITERAL;
terminal FloatLiteral FLOAT_LITERAL;
terminal BoolLiteral BOOL_LITERAL;

/* Non terminals */
non terminal	program,
				set_decl,
				field_decl,
				id_field_decl,
				list_id_field_decl,
				set_field_decl,
				method_decl,
				set_method_decl,
				zero_or_one_list_type_id_method_decl,
				list_type_id_method_decl,
				type_id_method_decl,
				list_expr,
				externinvk_arg,
				list_externinvk_arg;
				
non terminal	Expression expr, zero_or_one_expr, location, method_call_expr;
non terminal 	AssignOpType assign_op;
non terminal 	Statement statement, zero_or_one_else_block, method_call_stmt;
non terminal 	BinOpType bin_op, arith_op, rel_op, eq_op, cond_op;
non terminal    Block block, _block;
non terminal    Type type;
non terminal    Literal literal;
non terminal 	LinkedList set_statement;

/* Precedences */
precedence left  EQ, ANDAND, NOT, NOTEQ;
precedence left  OROR;
precedence left  LT, GT, LTEQ, GTEQ, EQEQ;
precedence left  PLUS, MINUS;
precedence left  MULT, DIV, MOD;

/* The grammar rules */
start with program;

program ::= 
		CLASS ID LBRACE {:table.insertNewBlock();:} set_decl RBRACE {:table.closeBlock();:} {:System.out.println("termino");:}
	|	CLASS ID LBRACE {:table.insertNewBlock();:} RBRACE {:table.closeBlock();:} {:System.out.println("termino");:}
	;

set_decl ::= 
		set_field_decl set_method_decl
	|	set_method_decl
	|	set_field_decl
	;

set_field_decl ::= 
		set_field_decl field_decl
	|	field_decl
	;

field_decl ::= type list_id_field_decl SEMICOLON;

id_field_decl ::= 
		ID:i {:table.insertSymbol(currentType, i);:} 
	|	ID:i {:table.insertSymbol(currentType, i);:} LBRACK INT_LITERAL RBRACK
	;

list_id_field_decl ::= list_id_field_decl COMMA id_field_decl | id_field_decl;

method_decl ::= 
		type ID:i {:table.insertSymbol(currentType, i);:} LPAREN zero_or_one_list_type_id_method_decl RPAREN block 
	|	VOID ID:i {:table.insertSymbol("Void", i);:} LPAREN zero_or_one_list_type_id_method_decl RPAREN block 
	;

set_method_decl ::= method_decl set_method_decl | method_decl;

zero_or_one_list_type_id_method_decl ::=
		list_type_id_method_decl
	|	/* LAMBDA */
	;

list_type_id_method_decl ::= type_id_method_decl COMMA list_type_id_method_decl | type_id_method_decl;

type_id_method_decl ::= type ID:i {:table.insertSymbol(currentType, i);:};

block ::= {:table.insertNewBlock();:} _block:b1 {:table.closeBlock();:} {: RESULT = b1; :};

_block ::= 
		LBRACE  set_field_decl set_statement:ss RBRACE
		{: RESULT = new Block(table.getCurrentLevel(), ss); :}		// Usamos set_field_declaration??
	|	LBRACE set_statement:ss RBRACE
		{: RESULT = new Block(table.getCurrentLevel(), ss); :} 
	|	LBRACE set_field_decl RBRACE
		{: RESULT = new Block(table.getCurrentLevel(), null); :} 
	;

type ::=
		TBOOLEAN {:currentType = "boolean";:}
	|	TFLOAT {:currentType = "float";:}
	|	TINT {:currentType = "int";:}
	;

statement ::=
		location:l1 assign_op:ap1 expr:e1 SEMICOLON
		{: RESULT = new AssignStmt((Location)l1, ap1, e1); :}
	|	method_call_stmt:mc SEMICOLON
		{: RESULT = mc; :}
	|	IF LPAREN expr:e1 RPAREN block:b1 zero_or_one_else_block:b2
		{: RESULT = new IfStmt(e1, (Block)b1, (Block)b2); :}
	|	FOR ID:id1 EQ expr:e1 COMMA expr:e2 block:b1 
		{: RESULT = new ForStmt(id1, e1, e2, (Block)b1); :}
	|	WHILE:w expr:e block:b          
		{:RESULT = new WhileStmt(e, (Block)b); :}
	|	RETURN zero_or_one_expr:e1 SEMICOLON
		{: RESULT = new ReturnStmt(e1); :}
	|	BREAK SEMICOLON
		{: RESULT = new BreakStmt(); :}
	|	CONTINUE SEMICOLON
		{: RESULT = new ContinueStmt(); :}
	|	SEMICOLON
		{: RESULT = new SemicolonStmt(); :}
	|	block:b1
		{: RESULT = b1; :}
	;

zero_or_one_else_block ::= 
		ELSE block:b1
		{: RESULT = b1; :}
	|	/* LAMBDA */
		{: RESULT = null; :}
	;
	
set_statement ::= 
		statement:s set_statement:ss
		{:	LinkedList<Statement> set_st = new LinkedList<Statement>();
			set_st.add(s);
			set_st.addAll(ss); :} 
	|	statement:s
		{:	LinkedList<Statement> set_st = new LinkedList<Statement>();
			set_st.add(s); :}
	;

zero_or_one_expr ::= 
		expr:e1
		{: RESULT = e1; :}
	|	/* LAMBDA */
		{: RESULT = null; :}
	;

assign_op ::=
		EQ
	|	PLUSEQ
	|	MINUSEQ
	;

method_call_stmt ::= 
		ID LPAREN  RPAREN
		//{: RESULT = new MethodCallStmt(); :}
	|	ID LPAREN list_expr RPAREN
		//{: RESULT = new MethodCallStmt(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type RPAREN
		//{: RESULT = new MethodCallStmt(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type COMMA list_externinvk_arg RPAREN
		//{: RESULT = new MethodCallStmt(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA VOID RPAREN
		//{: RESULT = new MethodCallStmt(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA VOID COMMA list_externinvk_arg RPAREN
		//{: RESULT = new MethodCallStmt(); :}
	;

method_call_expr ::= 
		ID LPAREN  RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	ID LPAREN list_expr RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type COMMA list_externinvk_arg RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA VOID RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA VOID COMMA list_externinvk_arg RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	;


location ::= 
		ID:id1
		{: RESULT = new VarLocation(id1); :}
	|	ID:id2 LBRACK expr RBRACK
		{: RESULT = new VarLocation(id2); :}
	;

list_expr ::= expr COMMA list_expr | expr;

expr ::=
		location:l1
		{: RESULT = l1; :}
	|	method_call_expr:m1
		{: RESULT = m1; :}
	|	literal:l1
		{: RESULT = l1; :}
	|	expr:el bin_op:bo1 expr:er
		{: RESULT = new BinOpExpr(el, bo1, er); :}
	|	MINUS:m1 expr:e1
		{: RESULT = new NegativeExpr(m1, e1); :}
	|	NOT:n1 expr:e1
		//{: RESULT = new NotExp(n1, e1); :}
	|	LPAREN expr RPAREN

	;

externinvk_arg ::=
		expr
	|	STRING_LITERAL
	;
	
list_externinvk_arg ::= 
		externinvk_arg COMMA list_externinvk_arg 
	|	externinvk_arg
	;

bin_op ::=
		arith_op:ao1
		{: RESULT = ao1; :}
	|	rel_op:ro1
		{: RESULT = ro1; :}
	|	eq_op:eo1
		{: RESULT = eo1; :}
	|	cond_op:co1
		{: RESULT = co1; :}
	;

arith_op ::=
		PLUS:op1
		{: RESULT = op1; :}
	|	MINUS:op2
		{: RESULT = op2; :}
	|	MULT:op3
		{: RESULT = op3; :}
	|	DIV:op4
		{: RESULT = op4; :}
	|	MOD:op5
		{: RESULT = op5; :}
	;

rel_op ::=
		LT:op1
		{: RESULT = op1; :}
	|	GT:op2
		{: RESULT = op2; :}
	|	LTEQ:op3
		{: RESULT = op3; :}
	|	GTEQ:op4
		{: RESULT = op4; :}
	;

eq_op ::=
		EQEQ:op1
		{: RESULT = op1; :}
	|	NOTEQ:op2
		{: RESULT = op2; :}
	;

cond_op ::=
		ANDAND:op1
		{: RESULT = op1; :}
	|	OROR:op2
		{: RESULT = op2; :}
	;
	
literal ::=
		INT_LITERAL:op1
		{: RESULT = op1; :}
	|	FLOAT_LITERAL:op2 
		{: RESULT = op2; :}
	|	BOOL_LITERAL:op3
		{: RESULT = op3; :}
	;

