/**
 * Copyright (C) 2014
 * All rights reserved.
 *
 * File Name: analizerSyntax.cup
 * To Create: cup analizerSyntax.cup
 * Authors: Astorga Dario - Marconi Pablo
 * Version: 0.1 
 */
import java_cup.runtime.*;
import ir.ast.*;
import java.util.*;

action code {:
	SymbolTable table = new SymbolTable();
	Type currentType;
	Boolean mainDeclared = false;
:}

/* Terminals (tokens obtained by the lexical analyzer) */
terminal BREAK;
terminal CLASS;
terminal CONTINUE;
terminal IF,ELSE;
terminal FOR;
terminal WHILE;
terminal RETURN;
terminal LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON, LPAREN, RPAREN, COMMA, EXTERNINVK;
terminal Type TVOID;			
terminal String ID;
terminal BinOpType PLUS, MINUS, MULT, DIV, MOD, LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ, ANDAND, NOT, OROR;
terminal AssignOpType PLUSEQ, MINUSEQ, EQ;
terminal Type TINT, TFLOAT, TBOOLEAN;
terminal IntLiteral INT_LITERAL;
terminal FloatLiteral FLOAT_LITERAL;
terminal BoolLiteral BOOL_LITERAL;
terminal String STRING_LITERAL;

/* Non terminals */
non terminal	program,
				set_decl,
				field_decl,
				id_field_decl,
				method_decl,
				set_field_decl,	
				set_method_decl,
				list_id_field_decl;
			
non terminal    Type type;
non terminal    Literal literal;
non terminal    Block block, _block;
non terminal 	AssignOpType assign_op;
non terminal 	BinOpType bin_op, arith_op, rel_op, eq_op, cond_op;
non terminal 	LinkedList set_statement, list_expr, list_externinvk_arg, list_type_id_method_decl, zero_or_one_list_type_id_method_decl;
non terminal 	Statement statement, zero_or_one_else_block, method_call_stmt;
non terminal	Expression expr, zero_or_one_expr, method_call_expr, externinvk_arg;
non terminal 	VarLocation location;
non terminal 	VarDescriptor type_id_method_decl;
/* Precedences */
precedence left  EQ, ANDAND, NOT, NOTEQ;
precedence left  OROR;
precedence left  LT, GT, LTEQ, GTEQ, EQEQ;
precedence left  PLUS, MINUS;
precedence left  MULT, DIV, MOD;

/* The grammar rules */
start with program;

program ::= 
		CLASS ID LBRACE {: table.insertNewBlock(); :} set_decl RBRACE {: table.closeBlock(); :} {:System.out.println("termino");:}
	|	CLASS ID LBRACE {: table.insertNewBlock(); :} RBRACE {: table.closeBlock(); :} {:System.out.println("termino");:}
	;

set_decl ::= 
		set_field_decl set_method_decl
	|	set_method_decl
	|	set_field_decl
	;

set_field_decl ::= 
		set_field_decl field_decl
	|	field_decl
	;

field_decl ::= type list_id_field_decl SEMICOLON;

id_field_decl ::= 
		ID:id1
		{:	if (table.searchInCurrentLevel(id1) == null) {	// Observo si ya existe un descriptor ya declarado con el mismo nombre en el mismo bloque.
				Descriptor d1 = new VarDescriptor(currentType, id1);
				table.insertNewDescriptor(d1);
			} else {
				// Ya existe un descriptor declarado con ese nombre.
			}
		:}
	|	ID:id1
		{:	if (table.searchInCurrentLevel(id1) == null) {	// Observo si ya existe un descriptor ya declarado con el mismo nombre en el mismo bloque.
				Descriptor d1;
				switch (currentType){
					case TINT:
						d1 = new VarDescriptor(Type.INTARRAY, id1);
						break;
					case TFLOAT:
						d1 = new VarDescriptor(Type.FLOATARRAY, id1);
						break;
					case TBOOLEAN:
						d1 = new VarDescriptor(Type.BOOLEANARRAY, id1);
						break;
					default:
						d1 = new VarDescriptor(Type.UNDEFINED, id1);
						break;
				};
				table.insertNewDescriptor(d1);
			} else {
				// Ya existe un descriptor declarado con ese nombre.
			}
		:}
		LBRACK INT_LITERAL RBRACK
	;

list_id_field_decl ::= list_id_field_decl COMMA id_field_decl | id_field_decl;

method_decl ::= 
		type:t1 ID:id1
		{:	if (id1.toString().equals("main")) {
				if (!mainDeclared) {
					mainDeclared = true;					
				}else {
					//ERROR: el metodo main ya ha sido declarado.
				}
			} else {	// Para un id diferente del main.
				if (table.searchInCurrentLevel(id1) == null) {	// Observo si ya existe un descriptor ya declarado con el mismo nombre en el mismo bloque.
					Descriptor m1 = new FunctionDescriptor(t1, id1);
					table.insertNewDescriptor(m1);
				} else {
					// Ya existe un descriptor declarado con ese nombre.
				};	
			}; :}
		LPAREN zero_or_one_list_type_id_method_decl:params
		{:	if (id1.toString().equals("main") && params.size() != 0){	// Si el metodo es main no debe tener parametros.
				// ERROR: el metodo main no puede tener parametros.
			}; :}
		RPAREN block
	|	TVOID:t1 ID:id1
		{:	if (id1.toString().equals("main")) {
				if (!mainDeclared) {
					mainDeclared = true;					
				}else {
					//ERROR: el metodo main ya ha sido declarado.
				}
			} else {	// Para un id diferente del main.
				if (table.searchInCurrentLevel(id1) == null) {	// Observo si ya existe un descriptor ya declarado con el mismo nombre en el mismo bloque.
					Descriptor m1 = new FunctionDescriptor(t1, id1);
					table.insertNewDescriptor(m1);
				} else {
					// Ya existe un descriptor declarado con ese nombre.
				}	
			}; :}
		LPAREN zero_or_one_list_type_id_method_decl:params
		{:	if (id1.toString().equals("main") && params.size() != 0){	// Si el metodo es main no debe tener parametros.
				// ERROR: el metodo main no puede tener parametros.
			}; :}
		RPAREN block
	;

set_method_decl ::= method_decl set_method_decl | method_decl;

zero_or_one_list_type_id_method_decl ::=
		list_type_id_method_decl:l1
		{: RESULT =  l1; :}
	|	/* LAMBDA */
		{: RESULT = new LinkedList<VarDescriptor>(); :}
	;

list_type_id_method_decl ::= 
		type_id_method_decl:d1 COMMA list_type_id_method_decl:l1
		{:	LinkedList<VarDescriptor> dlist = new LinkedList<VarDescriptor>();
			dlist.add(d1);
			dlist.addAll(l1);
			RESULT = dlist; :}
	|	type_id_method_decl:d1
		{:	LinkedList<VarDescriptor> dlist = new LinkedList<VarDescriptor>();
			dlist.add(d1);
			RESULT = dlist; :} 
	;

type_id_method_decl ::= 
		type ID:id1
		{:	table.insertSymbol(currentType, id1);
			RESULT = new VarDescriptor(currentType, id1); :};

block ::= {:table.insertNewBlock();:} _block:b1 {:table.closeBlock();:} {: RESULT = b1; :};

_block ::= 
		LBRACE  set_field_decl set_statement:ss RBRACE
		{: RESULT = new Block(table.getCurrentLevel(), ss); :}		// Usamos set_field_declaration??
	|	LBRACE set_statement:ss RBRACE
		{: RESULT = new Block(table.getCurrentLevel(), ss); :} 
	|	LBRACE set_field_decl RBRACE
		{: RESULT = new Block(table.getCurrentLevel(), null); :} 
	;

type ::=
		TBOOLEAN:t {:currentType = t;:}
	|	TFLOAT:t {:currentType = t;:}
	|	TINT:t {:currentType = t;:}
	;

statement ::=
		location:l1 assign_op:ap1 expr:e1 SEMICOLON
		{: RESULT = new AssignStmt(l1, ap1, e1); :}
	|	method_call_stmt:mc SEMICOLON
		{: RESULT = mc; :}
	|	IF LPAREN expr:e1 RPAREN block:b1 zero_or_one_else_block:b2
		{: RESULT = new IfStmt(e1, (Block)b1, (Block)b2); :}
	|	FOR ID:id1 EQ expr:e1 COMMA expr:e2 block:b1 
		{:	if (table.search(id1) != null) {	// Observo si ya existe un descriptor ya declarado con el mismo nombre en el mismo bloque.
				RESULT = new ForStmt(id1, e1, e2, (Block)b1);	// FALTA OBSERVAR SI DICHO DESCRIPTOR ES UNA VARIABLE Y NO OTRA COSA!!
			} else {
				// No exite un metodo declarado con ese Id.
				RESULT = null;
			}; :}
		/*{: RESULT = new ForStmt(id1, e1, e2, (Block)b1); :}*/
	|	WHILE expr:e block:b
		{:RESULT = new WhileStmt(e, (Block)b); :}
	|	RETURN zero_or_one_expr:e1 SEMICOLON
		{: RESULT = new ReturnStmt(e1); :}
	|	BREAK SEMICOLON
		{: RESULT = new BreakStmt(); :}
	|	CONTINUE SEMICOLON
		{: RESULT = new ContinueStmt(); :}
	|	SEMICOLON
		{: RESULT = new SemicolonStmt(); :}
	|	block:b1
		{: RESULT = b1; :}
	;

zero_or_one_else_block ::= 
		ELSE block:b1
		{: RESULT = b1; :}
	|	/* LAMBDA */
		{: RESULT = null; :}
	;
	
set_statement ::= 
		statement:s set_statement:ss
		{:	LinkedList<Statement> set_st = new LinkedList<Statement>();
			set_st.add(s);
			set_st.addAll(ss);
			RESULT = set_st; :} 
	|	statement:s
		{:	LinkedList<Statement> set_st = new LinkedList<Statement>();
			set_st.add(s);
			RESULT = set_st; :}
	;

zero_or_one_expr ::= 
		expr:e1
		{: RESULT = e1; :}
	|	/* LAMBDA */
		{: RESULT = null; :}
	;

assign_op ::=
		EQ:op1
		{: RESULT = op1; :}
	|	PLUSEQ:op2
		{: RESULT = op2; :}
	|	MINUSEQ:op3
		{: RESULT = op3; :}
	;

method_call_stmt ::= 
		ID:id1 LPAREN  RPAREN
		{:	if (table.search(id1) != null) {	// Observo si ya existe un descriptor ya declarado en la tabla con el mismo nombre.
				RESULT = new MethodCallStmt(id1);	// FALTA FIJARSE SI EL DESCRIPTOR ENCONTRADO ES UN METODO!!!!
			} else {
				// No exite un metodo declarado con ese Id.
				RESULT = null;
			}; :}
	|	ID:id1 LPAREN list_expr:le RPAREN
		{:	if (table.search(id1) != null) {	// Observo si ya existe un descriptor ya declarado en la tabla con el mismo nombre.
				RESULT = new MethodCallStmt(id1, le);	// FALTA FIJARSE SI EL DESCRIPTOR ENCONTRADO ES UN METODO!!!!
			} else {
				// No exite un metodo declarado con ese Id.
				RESULT = null;
			}; :}
	|	EXTERNINVK LPAREN STRING_LITERAL:id1 COMMA type:t RPAREN
		{: RESULT = new ExternInvkStmt(id1, t); :}
	|	EXTERNINVK LPAREN STRING_LITERAL:id1 COMMA type:t COMMA list_externinvk_arg:l RPAREN
		{: RESULT = new ExternInvkStmt(id1, t, l); :}
	|	EXTERNINVK LPAREN STRING_LITERAL:id1 COMMA TVOID:t RPAREN
		{: RESULT = new ExternInvkStmt(id1, t); :}
	|	EXTERNINVK LPAREN STRING_LITERAL:id1 COMMA TVOID:t COMMA list_externinvk_arg:l RPAREN
		{: RESULT = new ExternInvkStmt(id1, t, l); :}
	;

method_call_expr ::= 
		ID LPAREN  RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	ID LPAREN list_expr RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA type COMMA list_externinvk_arg RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA TVOID RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	|	EXTERNINVK LPAREN STRING_LITERAL COMMA TVOID COMMA list_externinvk_arg RPAREN
		//{: RESULT = new MethodCallExpr(); :}
	;

location ::= 
		ID:id1
		{:	if (table.search(id1) != null) {	// Observo si ya existe un descriptor ya declarado en la tabla con el mismo nombre.
				RESULT = new VarLocation(id1);	// FALTA! HAY Q CHEQUEAR  QUE DEBE SER VARIABLE!
			} else {
				// No exite un location declarado con ese Id.
				RESULT = null;
			}; :}
	|	ID:id1 LBRACK expr RBRACK
		{:	if (table.search(id1) != null) {	// Observo si ya existe un descriptor ya declarado en la tabla con el mismo nombre.
				RESULT = new VarLocation(id1);	// FALTA! DEBE SER DEL TIPO ARRAY!
			} else {
				// No exite un location declarado con ese Id.
				RESULT = null;
			}; :}
	;

list_expr ::= 
		expr:e1 COMMA list_expr:lexpr
		{:	LinkedList<Expression> list_e = new LinkedList<Expression>();
			list_e.add(e1);
			list_e.addAll(lexpr);
			RESULT = list_e; :}
	|	expr:e1
		{:	LinkedList<Expression> list_e = new LinkedList<Expression>();
			list_e.add(e1);
			RESULT = list_e; :}
	;

expr ::=
		location:l1
		{: RESULT = l1; :}
	|	method_call_expr:m1
		{: RESULT = m1; :}
	|	literal:l1
		{: RESULT = l1; :}
	|	expr:el bin_op:bo1 expr:er
		{: RESULT = new BinOpExpr(el, bo1, er); :}
	|	MINUS:m1 expr:e1
		{: RESULT = new NegativeExpr(m1, e1); :}
	|	NOT:n1 expr:e1
		{: RESULT = new NotExp(n1, e1); :}
	|	LPAREN expr RPAREN
	;

externinvk_arg ::=
		expr:e1
		{: RESULT = new ExternInvkArgExpr(e1); :}
	|	STRING_LITERAL:s1
		{: RESULT = new ExternInvkArgStringLit(s1); :}
	;
	
list_externinvk_arg ::= 
		externinvk_arg:ei COMMA list_externinvk_arg:lei
		{:	LinkedList<Expression> list_ei = new LinkedList<Expression>();
			list_ei.add(ei);
			list_ei.addAll(lei);
			RESULT = list_ei; :}
	|	externinvk_arg:e1
		{:	LinkedList<Expression> list_ei = new LinkedList<Expression>();
			list_ei.add(e1);
			RESULT = list_ei; :}
	;

bin_op ::=
		arith_op:ao1
		{: RESULT = ao1; :}
	|	rel_op:ro1
		{: RESULT = ro1; :}
	|	eq_op:eo1
		{: RESULT = eo1; :}
	|	cond_op:co1
		{: RESULT = co1; :}
	;

arith_op ::=
		PLUS:op1
		{: RESULT = op1; :}
	|	MINUS:op2
		{: RESULT = op2; :}
	|	MULT:op3
		{: RESULT = op3; :}
	|	DIV:op4
		{: RESULT = op4; :}
	|	MOD:op5
		{: RESULT = op5; :}
	;

rel_op ::=
		LT:op1
		{: RESULT = op1; :}
	|	GT:op2
		{: RESULT = op2; :}
	|	LTEQ:op3
		{: RESULT = op3; :}
	|	GTEQ:op4
		{: RESULT = op4; :}
	;

eq_op ::=
		EQEQ:op1
		{: RESULT = op1; :}
	|	NOTEQ:op2
		{: RESULT = op2; :}
	;

cond_op ::=
		ANDAND:op1
		{: RESULT = op1; :}
	|	OROR:op2
		{: RESULT = op2; :}
	;
	
literal ::=
		INT_LITERAL:op1
		{: RESULT = op1; :}
	|	FLOAT_LITERAL:op2 
		{: RESULT = op2; :}
	|	BOOL_LITERAL:op3
		{: RESULT = op3; :}
	;

